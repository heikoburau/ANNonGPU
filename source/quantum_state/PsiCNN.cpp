#ifdef ENABLE_PSI_CNN

#include "quantum_state/PsiCNN.hpp"


namespace ann_on_gpu {


template<typename dtype>
void PsiCNN_t<dtype>::init_kernel() {
    this->num_layers = this->num_channels_list.size();
    this->num_params = this->params.size();

    this->num_angles = 0u;
    auto params_offset = 0u;
    for(auto l = 0u; l < this->num_layers; l++) {
        auto& layer = this->layers[l];

        layer.num_channels = this->num_channels_list[l];
        layer.num_channel_links = layer.num_channels * (
            l > 0 ? this->layers[l - 1u].num_channels : 1u
        );
        layer.connectivity = this->connectivity_list[l];

        for(auto cl = 0u; cl < layer.num_channel_links; cl++) {
            auto& channel_link = layer.channel_links[cl];

            channel_link.begin_params = params_offset;
            channel_link.weights = this->params.data() + params_offset;

            params_offset += layer.connectivity;
        }

        this->num_angles += layer.num_channels * this->N;
    }

    if(this->angles.empty()) {
        this->angles.resize(this->num_angles);
    }

    this->init_kernel_angles();
}


template<typename dtype>
void PsiCNN_t<dtype>::init_kernel_angles() {
    auto angles_offset = 0u;
    for(auto l = 0u; l < this->num_layers; l++) {
        auto& layer = this->layers[l];

        for(auto c = 0u; c < layer.num_channels; c++) {
            auto& channel = layer.channels[c];

            channel.angles = this->angles.data() + angles_offset;

            angles_offset += this->N;
        }
    }
}

template<typename dtype>
void PsiCNN_t<dtype>::init_gradient(const unsigned int num_steps) {
    this->angles.resize(num_steps * this->num_angles);
    this->init_kernel_angles();
}


template struct PsiCNN_t<double>;
template struct PsiCNN_t<complex_t>;

} // namespace ann_on_gpu

#endif // ENABLE_PSI_CNN
